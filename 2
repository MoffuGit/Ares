const std = @import("std");
const Allocator = std.mem.Allocator;
const assert = std.debug.assert;
const panic = std.debug.panic;

const BASE: usize = 6;
const CAPACITY: usize = 2 * BASE;

pub const Error = error{
    OutOfMemory,
    DuplicateKey,
} || Allocator.Error;

pub fn NodeType(comptime K: type, comptime V: type, comp: *const fn (a: K, b: K) std.math.Order) type {
    return union(enum) {
        const Self = @This();

        Internal: struct { childs: [CAPACITY]*Self = undefined, keys: [CAPACITY]K = undefined, len: u16 = 0, height: usize = 0 },
        Leaf: struct { items: [CAPACITY]V = undefined, keys: [CAPACITY]K = undefined, len: u16 = 0 },

        pub fn add_item(self: *Self, key: K, value: V) Error!void {
            switch (self.*) {
                .Internal => panic("items can be only added to leaf nodes", .{}),
                .Leaf => |*leaf| {
                    if (leaf.len == leaf.items.len) {
                        return error.OutOfMemory;
                    }

                    var idx: u16 = leaf.len;

                    while (idx > 0) : (idx -= 1) {
                        switch (comp(key, leaf.keys[idx - 1])) {
                            .gt => break,
                            .lt => {
                                leaf.keys[idx] = leaf.keys[idx - 1];
                                leaf.items[idx] = leaf.items[idx - 1];
                            },
                            .eq => return error.DuplicateKey,
                        }
                    }

                    leaf.keys[idx] = key;
                    leaf.items[idx] = value;
                    leaf.len += 1;
                },
            }
        }

        pub fn add_child(self: *Self, key: K, child: *Self) Error!void {
            switch (self.*) {
                .Internal => |*int| {
                    if (int.len == int.childs.len) {
                        return error.OutOfMemory;
                    }

                    var idx: u16 = int.len;

                    while (idx > 0) : (idx -= 1) {
                        switch (comp(key, int.keys[idx - 1])) {
                            .gt => break,
                            .lt => {
                                int.keys[idx] = int.keys[idx - 1];
                                int.childs[idx] = int.childs[idx - 1];
                            },
                            .eq => return error.DuplicateKey,
                        }
                    }

                    int.keys[idx] = key;
                    int.childs[idx] = child;
                    int.len += 1;
                },
                .Leaf => panic("childs can be only added to internal nodes", .{}),
            }
        }

        pub fn items(self: *Self) *const [CAPACITY]V {
            switch (self.*) {
                .Internal => panic("Internal nodes have not items", .{}),
                .Leaf => |leaf| return &leaf.items,
            }
        }

        pub fn keys(self: *Self) *const [CAPACITY]K {
            switch (self.*) {
                .Internal => |*internal| {
                    return &internal.keys;
                },
                .Leaf => |*leaf| {
                    return &leaf.keys;
                },
            }
        }

        pub fn is_empty(self: *Self) bool {
            switch (self.*) {
                .Internal => return false,
                .Leaf => |leaf| {
                    return leaf.len == 0;
                },
            }
        }

        pub fn len(self: *Self) u16 {
            switch (self.*) {
                .Internal => |int| return int.len,
                .Leaf => |leaf| return leaf.len,
            }
        }

        pub fn is_leaf(self: *Self) bool {
            switch (self.*) {
                .Internal => return false,
                .Leaf => return true,
            }
        }

        pub fn height(self: *Self) usize {
            switch (self.*) {
                .Internal => |internal| return internal.height,
                .Leaf => return 0,
            }
        }

        pub fn is_underflowing(self: *Self) bool {
            switch (self.*) {
                .Internal => |int| {
                    return int.len < BASE;
                },
                .Leaf => |leaf| {
                    return leaf.len <
                        BASE;
                },
            }
        }

        pub fn childs(self: *Self) *const [CAPACITY]*Self {
            switch (self.*) {
                .Internal => |internal| return &internal.childs,
                .Leaf => panic("Leaf nodes have no childs", .{}),
            }
        }

        pub fn destroy(self: *Self, alloc: Allocator) void {
            switch (self.*) {
                .Internal => |*internal| {
                    if (internal.len > 0) {
                        for (0..internal.len) |idx| {
                            internal.childs[idx].destroy(alloc);
                        }
                    }
                },
                else => {},
            }
            alloc.destroy(self);
        }

        pub fn append(self: *Self, other: *Self, alloc: Allocator) Error!void {
            if (self.is_empty()) {
                self.* = other.*;
            } else if (!other.is_leaf() or other.items().len != 0) {
                if (self.height() < other.height()) {
                    for (other.childs()) |node| {
                        try self.append(node, alloc);
                    }
                } else if (try self.append_recursive(other, alloc)) |right| {
                    const left = try alloc.create(Self);
                    left.* = self.*;
                    self.* = try Self.from_child_nodes(left, right);
                }
            }
        }

        pub fn from_child_nodes(left: *Self, right: *Self) !Self {
            var childrens: [CAPACITY]*Self = undefined;
            childrens[0] = left;
            childrens[1] = right;

            var _keys: [CAPACITY]K = undefined;
            _keys[0] = right.keys()[0];

            return .{ .Internal = .{ .height = left.height() + 1, .len = 2, .childs = childrens, .keys = _keys } };
        }

        pub fn append_recursive(self: *Self, other: *Self, alloc: Allocator) Error!?*Self {
            switch (self.*) {
                .Internal => |*internal| {
                    const height_delta = internal.height - other.height();
                    var keys_to_append: [CAPACITY]K = undefined;
                    var childs_to_append: [CAPACITY]*Self = undefined;
                    var len_to_append: usize = 0;

                    if (height_delta == 0) {
                        @memcpy(&keys_to_append, other.keys());
                        @memcpy(&childs_to_append, other.childs());
                        len_to_append = other.len();
                    } else if (height_delta == 1 and !other.is_underflowing()) {
                        keys_to_append[0] = other.keys()[0];
                        childs_to_append[0] = other;
                        len_to_append = 1;
                    } else {
                        const node_to_append = try internal.childs[internal.len - 1].append_recursive(other, alloc);
                        internal.keys[internal.len] = internal.childs[internal.len - 1].keys()[0];
                        if (node_to_append) |split| {
                            keys_to_append[0] = split.keys()[0];
                            childs_to_append[0] = split;
                            len_to_append = 1;
                        }
                    }

                    const childs_len = internal.len + len_to_append;
                    if (childs_len > CAPACITY) {
                        return null;
                    } else {
                        var idx: u16 = 0;
                        while (idx < len_to_append) : (idx += 1) {
                            const item = childs_to_append[idx];
                            const key = keys_to_append[idx];

                            try self.add_child(key, item);
                        }
                        return null;
                    }
                },
                .Leaf => |*leaf| {
                    const other_leaf = other.Leaf;

                    const items_len = leaf.len + other_leaf.len;

                    if (items_len > CAPACITY) {
                        var left_items: [CAPACITY]V = undefined;
                        var right_items: [CAPACITY]V = undefined;

                        var left_keys: [CAPACITY]K = undefined;
                        var right_keys: [CAPACITY]K = undefined;

                        const mid = (items_len + items_len % 2) / 2;

                        var p: usize = 0;
                        var c: usize = 0;

                        for (0..items_len) |idx| {
                            if (p < leaf.len and (c >= other_leaf.len or comp(leaf.keys[p], other_leaf.keys[c]) == .lt)) {
                                if (idx < mid) {
                                    left_items[idx] = leaf.items[p];
                                    left_keys[idx] = leaf.keys[p];
                                } else {
                                    right_items[idx - mid] = leaf.items[p];
                                    right_keys[idx - mid] = leaf.keys[p];
                                }
                                p += 1;
                            } else if (c < other_leaf.len and (p >= leaf.len or comp(leaf.keys[p], other_leaf.keys[c]) == .gt)) {
                                if (idx < mid) {
                                    left_items[idx] = other_leaf.items[c];
                                    left_keys[idx] = other_leaf.keys[c];
                                } else {
                                    right_items[idx - mid] = other_leaf.items[c];
                                    right_keys[idx - mid] = other_leaf.keys[c];
                                }
                                c += 1;
                            }
                        }

                        leaf.items = left_items;
                        leaf.keys = left_keys;
                        leaf.len = mid;

                        const right_node = try alloc.create(Self);
                        right_node.* = .{ .Leaf = .{ .items = right_items, .keys = right_keys, .len = items_len - mid } };
                        return right_node;
                    } else {
                        var idx: u16 = 0;
                        while (idx < other_leaf.len) : (idx += 1) {
                            const item = other_leaf.items[idx];
                            const key = other_leaf.keys[idx];

                            try self.add_item(key, item);
                        }
                        return null;
                    }
                },
            }
        }
    };
}

pub fn BPlusTree(comptime K: type, comptime V: type, comptime comp: *const fn (a: K, b: K) std.math.Order) type {
    const Node = NodeType(K, V, comp);

    return struct {
        const Self = @This();

        root: *Node,
        alloc: Allocator,

        pub fn init(alloc: Allocator) !Self {
            const root = try alloc.create(Node);
            root.* = .{ .Leaf = .{} };

            return .{ .root = root, .alloc = alloc };
        }

        pub fn deinit(self: Self) void {
            self.root.destroy(self.alloc);
        }

        pub fn push(self: *Self, key: K, value: V) Error!void {
            var node: Node = Node{ .Leaf = .{} };

            try node.add_item(key, value);

            try self.root.append(&node, self.alloc);
        }
    };
}

fn test_comp(a: usize, b: usize) std.math.Order {
    return std.math.order(a, b);
}

test "init B+ tree and first push value" {
    const testing = std.testing;
    const alloc = testing.allocator;

    const T = BPlusTree(usize, usize, test_comp);
    var tree = try T.init(alloc);
    defer tree.deinit();

    try tree.push(0, 1);

    assert(!tree.root.is_empty());
    assert(tree.root.is_leaf());

    try tree.push(1, 1);
    try tree.push(2, 1);
    try tree.push(3, 1);
    try tree.push(4, 1);
    try tree.push(5, 1);
    try tree.push(6, 1);
    try tree.push(7, 1);
    try tree.push(8, 1);
    try tree.push(9, 1);
    try tree.push(10, 1);
    try tree.push(11, 1);
    try tree.push(12, 1);

    std.log.err("{}", .{tree});

    assert(!tree.root.is_leaf());

    // try tree.push(13, 1);
}
